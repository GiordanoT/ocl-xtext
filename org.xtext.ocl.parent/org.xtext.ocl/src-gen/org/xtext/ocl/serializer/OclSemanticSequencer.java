/*
 * generated by Xtext 2.26.0-SNAPSHOT
 */
package org.xtext.ocl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.ocl.ocl.ActualParameterList;
import org.xtext.ocl.ocl.AddOperator;
import org.xtext.ocl.ocl.AdditiveExpression;
import org.xtext.ocl.ocl.Attribute;
import org.xtext.ocl.ocl.CollectionKind;
import org.xtext.ocl.ocl.Declarator;
import org.xtext.ocl.ocl.EnumerationType;
import org.xtext.ocl.ocl.ExpressionListOrRange;
import org.xtext.ocl.ocl.FeatureCallParameters;
import org.xtext.ocl.ocl.IfExpression;
import org.xtext.ocl.ocl.Literal;
import org.xtext.ocl.ocl.LiteralCollection;
import org.xtext.ocl.ocl.LogicalExpression;
import org.xtext.ocl.ocl.LogicalOperator;
import org.xtext.ocl.ocl.MultiplicativeExpression;
import org.xtext.ocl.ocl.MultiplyOperator;
import org.xtext.ocl.ocl.NavigationOperator;
import org.xtext.ocl.ocl.NoParamFunction;
import org.xtext.ocl.ocl.OclPackage;
import org.xtext.ocl.ocl.OneIntegerParamFunction;
import org.xtext.ocl.ocl.OneStringParamFunction;
import org.xtext.ocl.ocl.OneTypeParamFunction;
import org.xtext.ocl.ocl.PathName;
import org.xtext.ocl.ocl.PathTypeName;
import org.xtext.ocl.ocl.RelationalExpression;
import org.xtext.ocl.ocl.RelationalOperator;
import org.xtext.ocl.ocl.TimeExpression;
import org.xtext.ocl.ocl.TwoIntegerParamFunction;
import org.xtext.ocl.ocl.TwoStringParamFunction;
import org.xtext.ocl.ocl.TypeName;
import org.xtext.ocl.ocl.UnaryExpression;
import org.xtext.ocl.ocl.UnaryOperator;
import org.xtext.ocl.services.OclGrammarAccess;

@SuppressWarnings("all")
public class OclSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OclGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OclPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OclPackage.ACTUAL_PARAMETER_LIST:
				sequence_ActualParameterList(context, (ActualParameterList) semanticObject); 
				return; 
			case OclPackage.ADD_OPERATOR:
				sequence_AddOperator(context, (AddOperator) semanticObject); 
				return; 
			case OclPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case OclPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case OclPackage.COLLECTION_KIND:
				sequence_CollectionKind(context, (CollectionKind) semanticObject); 
				return; 
			case OclPackage.DECLARATOR:
				sequence_Declarator(context, (Declarator) semanticObject); 
				return; 
			case OclPackage.ENUMERATION_TYPE:
				sequence_EnumerationType(context, (EnumerationType) semanticObject); 
				return; 
			case OclPackage.EXPRESSION_LIST_OR_RANGE:
				sequence_ExpressionListOrRange(context, (ExpressionListOrRange) semanticObject); 
				return; 
			case OclPackage.FEATURE_CALL_PARAMETERS:
				sequence_FeatureCallParameters(context, (FeatureCallParameters) semanticObject); 
				return; 
			case OclPackage.IF_EXPRESSION:
				if (rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getIfExpressionRule()) {
					sequence_IfExpression(context, (IfExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixExpressionRule()) {
					sequence_IfExpression_PostfixExpression(context, (IfExpression) semanticObject); 
					return; 
				}
				else break;
			case OclPackage.LITERAL:
				if (rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getLiteralRule()) {
					sequence_Literal(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixExpressionRule()) {
					sequence_Literal_PostfixExpression(context, (Literal) semanticObject); 
					return; 
				}
				else break;
			case OclPackage.LITERAL_COLLECTION:
				if (rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getLiteralCollectionRule()) {
					sequence_LiteralCollection(context, (LiteralCollection) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixExpressionRule()) {
					sequence_LiteralCollection_PostfixExpression(context, (LiteralCollection) semanticObject); 
					return; 
				}
				else break;
			case OclPackage.LOGICAL_EXPRESSION:
				if (rule == grammarAccess.getStartRule()
						|| rule == grammarAccess.getContextExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getLogicalExpressionRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()) {
					sequence_LogicalExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixExpressionRule()) {
					sequence_LogicalExpression_PostfixExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else break;
			case OclPackage.LOGICAL_OPERATOR:
				sequence_LogicalOperator(context, (LogicalOperator) semanticObject); 
				return; 
			case OclPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case OclPackage.MULTIPLY_OPERATOR:
				sequence_MultiplyOperator(context, (MultiplyOperator) semanticObject); 
				return; 
			case OclPackage.NAVIGATION_OPERATOR:
				sequence_NavigationOperator(context, (NavigationOperator) semanticObject); 
				return; 
			case OclPackage.NO_PARAM_FUNCTION:
				sequence_NoParamFunction(context, (NoParamFunction) semanticObject); 
				return; 
			case OclPackage.ONE_INTEGER_PARAM_FUNCTION:
				sequence_OneIntegerParamFunction(context, (OneIntegerParamFunction) semanticObject); 
				return; 
			case OclPackage.ONE_STRING_PARAM_FUNCTION:
				sequence_OneStringParamFunction(context, (OneStringParamFunction) semanticObject); 
				return; 
			case OclPackage.ONE_TYPE_PARAM_FUNCTION:
				sequence_OneTypeParamFunction(context, (OneTypeParamFunction) semanticObject); 
				return; 
			case OclPackage.PATH_NAME:
				if (rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getFeatureCallRule()) {
					sequence_FeatureCall_PathName(context, (PathName) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixExpressionRule()) {
					sequence_FeatureCall_PathName_PostfixExpression(context, (PathName) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPathNameRule()) {
					sequence_PathName(context, (PathName) semanticObject); 
					return; 
				}
				else break;
			case OclPackage.PATH_TYPE_NAME:
				sequence_PathTypeName(context, (PathTypeName) semanticObject); 
				return; 
			case OclPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case OclPackage.RELATIONAL_OPERATOR:
				sequence_RelationalOperator(context, (RelationalOperator) semanticObject); 
				return; 
			case OclPackage.TIME_EXPRESSION:
				sequence_TimeExpression(context, (TimeExpression) semanticObject); 
				return; 
			case OclPackage.TWO_INTEGER_PARAM_FUNCTION:
				sequence_TwoIntegerParamFunction(context, (TwoIntegerParamFunction) semanticObject); 
				return; 
			case OclPackage.TWO_STRING_PARAM_FUNCTION:
				sequence_TwoStringParamFunction(context, (TwoStringParamFunction) semanticObject); 
				return; 
			case OclPackage.TYPE_NAME:
				sequence_TypeName(context, (TypeName) semanticObject); 
				return; 
			case OclPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case OclPackage.UNARY_OPERATOR:
				sequence_UnaryOperator(context, (UnaryOperator) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Qualifiers returns ActualParameterList
	 *     ActualParameterList returns ActualParameterList
	 *
	 * Constraint:
	 *     (exp+=Expression exp+=Expression*)
	 * </pre>
	 */
	protected void sequence_ActualParameterList(ISerializationContext context, ActualParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AddOperator returns AddOperator
	 *
	 * Constraint:
	 *     (name='+' | name='-')
	 * </pre>
	 */
	protected void sequence_AddOperator(ISerializationContext context, AddOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdditiveExpression returns AdditiveExpression
	 *
	 * Constraint:
	 *     (exp+=MultiplicativeExpression (op+=AddOperator exp+=MultiplicativeExpression)*)
	 * </pre>
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, AdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Name returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     name=NAME_TERMINAL
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameNAME_TERMINALTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CollectionKind returns CollectionKind
	 *
	 * Constraint:
	 *     (name='Set' | name='Bag' | name='Sequence' | name='Collection')
	 * </pre>
	 */
	protected void sequence_CollectionKind(ISerializationContext context, CollectionKind semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declarator returns Declarator
	 *
	 * Constraint:
	 *     (name+=Name name+=Name* type=SimpleTypeSpecifier?)
	 * </pre>
	 */
	protected void sequence_Declarator(ISerializationContext context, Declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumerationType returns EnumerationType
	 *     SimpleTypeSpecifier returns EnumerationType
	 *
	 * Constraint:
	 *     (left=Name rights+=Name*)
	 * </pre>
	 */
	protected void sequence_EnumerationType(ISerializationContext context, EnumerationType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExpressionListOrRange returns ExpressionListOrRange
	 *
	 * Constraint:
	 *     (exp+=Expression (exp+=Expression+ | exp+=Expression)?)
	 * </pre>
	 */
	protected void sequence_ExpressionListOrRange(ISerializationContext context, ExpressionListOrRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FeatureCallParameters returns FeatureCallParameters
	 *
	 * Constraint:
	 *     (decs=Declarator? params=ActualParameterList)
	 * </pre>
	 */
	protected void sequence_FeatureCallParameters(ISerializationContext context, FeatureCallParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrimaryExpression returns PathName
	 *     FeatureCall returns PathName
	 *
	 * Constraint:
	 *     (
	 *         (left=TypeName | left=Name) 
	 *         rights+=Name? 
	 *         (rights+=TypeName? rights+=Name?)* 
	 *         params+=TimeExpression? 
	 *         params+=Qualifiers? 
	 *         params+=FeatureCallParameters?
	 *     )
	 * </pre>
	 */
	protected void sequence_FeatureCall_PathName(ISerializationContext context, PathName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixExpression returns PathName
	 *
	 * Constraint:
	 *     (
	 *         (left=TypeName | left=Name) 
	 *         rights+=Name? 
	 *         (rights+=TypeName? rights+=Name?)* 
	 *         params+=TimeExpression? 
	 *         params+=Qualifiers? 
	 *         params+=FeatureCallParameters? 
	 *         (op+=NavigationOperator features+=FeatureCall)*
	 *     )
	 * </pre>
	 */
	protected void sequence_FeatureCall_PathName_PostfixExpression(ISerializationContext context, PathName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrimaryExpression returns IfExpression
	 *     IfExpression returns IfExpression
	 *
	 * Constraint:
	 *     (exp+=Expression exp+=Expression exp+=Expression?)
	 * </pre>
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixExpression returns IfExpression
	 *
	 * Constraint:
	 *     (exp+=Expression exp+=Expression exp+=Expression? (op+=NavigationOperator features+=FeatureCall)*)
	 * </pre>
	 */
	protected void sequence_IfExpression_PostfixExpression(ISerializationContext context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrimaryExpression returns LiteralCollection
	 *     LiteralCollection returns LiteralCollection
	 *
	 * Constraint:
	 *     (name=CollectionKind exp=ExpressionListOrRange?)
	 * </pre>
	 */
	protected void sequence_LiteralCollection(ISerializationContext context, LiteralCollection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixExpression returns LiteralCollection
	 *
	 * Constraint:
	 *     (name=CollectionKind exp=ExpressionListOrRange? (op+=NavigationOperator features+=FeatureCall)*)
	 * </pre>
	 */
	protected void sequence_LiteralCollection_PostfixExpression(ISerializationContext context, LiteralCollection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrimaryExpression returns Literal
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     (name=STRING | name=NUMBER | name=NAME_TERMINAL)
	 * </pre>
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixExpression returns Literal
	 *
	 * Constraint:
	 *     ((name=STRING | name=NUMBER | name=NAME_TERMINAL) (op+=NavigationOperator features+=FeatureCall)*)
	 * </pre>
	 */
	protected void sequence_Literal_PostfixExpression(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Start returns LogicalExpression
	 *     ContextExpression returns LogicalExpression
	 *     Expression returns LogicalExpression
	 *     LogicalExpression returns LogicalExpression
	 *     PrimaryExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (exp+=RelationalExpression (op+=LogicalOperator exp+=RelationalExpression)*)
	 * </pre>
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (exp+=RelationalExpression (op+=LogicalOperator exp+=RelationalExpression)* (op+=NavigationOperator features+=FeatureCall)*)
	 * </pre>
	 */
	protected void sequence_LogicalExpression_PostfixExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalOperator returns LogicalOperator
	 *
	 * Constraint:
	 *     (name='and' | name='or' | name='xor' | name='implies')
	 * </pre>
	 */
	protected void sequence_LogicalOperator(ISerializationContext context, LogicalOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (exp+=UnaryExpression (op+=MultiplyOperator exp+=UnaryExpression)*)
	 * </pre>
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MultiplyOperator returns MultiplyOperator
	 *
	 * Constraint:
	 *     (name='*' | name='/')
	 * </pre>
	 */
	protected void sequence_MultiplyOperator(ISerializationContext context, MultiplyOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NavigationOperator returns NavigationOperator
	 *
	 * Constraint:
	 *     (name='.' | name='-&gt;')
	 * </pre>
	 */
	protected void sequence_NavigationOperator(ISerializationContext context, NavigationOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Name returns NoParamFunction
	 *     Function returns NoParamFunction
	 *     NoParamFunction returns NoParamFunction
	 *
	 * Constraint:
	 *     (
	 *         name='allInstaces' | 
	 *         name='oclType' | 
	 *         name='toString' | 
	 *         name='refImmediateComposite' | 
	 *         name='size' | 
	 *         name='toInteger' | 
	 *         name='toUpper' | 
	 *         name='toReal' | 
	 *         name='toLower' | 
	 *         name='toSequence' | 
	 *         name='trim' | 
	 *         name='isEmpty' | 
	 *         name='oclIsUndefined' | 
	 *         name='floor' | 
	 *         name='round' | 
	 *         name='notEmpty' | 
	 *         name='asBag' | 
	 *         name='asSequence' | 
	 *         name='sum' | 
	 *         name='asSet' | 
	 *         name='flatten' | 
	 *         name='first' | 
	 *         name='last'
	 *     )
	 * </pre>
	 */
	protected void sequence_NoParamFunction(ISerializationContext context, NoParamFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Name returns OneIntegerParamFunction
	 *     Function returns OneIntegerParamFunction
	 *     OneIntegerParamFunction returns OneIntegerParamFunction
	 *
	 * Constraint:
	 *     name='at'
	 * </pre>
	 */
	protected void sequence_OneIntegerParamFunction(ISerializationContext context, OneIntegerParamFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOneIntegerParamFunctionAccess().getNameAtKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Name returns OneStringParamFunction
	 *     Function returns OneStringParamFunction
	 *     OneStringParamFunction returns OneStringParamFunction
	 *
	 * Constraint:
	 *     (
	 *         name='concat' | 
	 *         name='startsWith' | 
	 *         name='endsWith' | 
	 *         name='indexOf' | 
	 *         name='lastIndexOf' | 
	 *         name='split'
	 *     )
	 * </pre>
	 */
	protected void sequence_OneStringParamFunction(ISerializationContext context, OneStringParamFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Name returns OneTypeParamFunction
	 *     Function returns OneTypeParamFunction
	 *     OneTypeParamFunction returns OneTypeParamFunction
	 *
	 * Constraint:
	 *     (name='oclTypeOf' | name='oclisKindOf')
	 * </pre>
	 */
	protected void sequence_OneTypeParamFunction(ISerializationContext context, OneTypeParamFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PathName returns PathName
	 *
	 * Constraint:
	 *     ((left=TypeName | left=Name) rights+=TypeName? (rights+=Name? rights+=TypeName?)*)
	 * </pre>
	 */
	protected void sequence_PathName(ISerializationContext context, PathName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleTypeSpecifier returns PathTypeName
	 *     PathTypeName returns PathTypeName
	 *
	 * Constraint:
	 *     (left=TypeName rights+=TypeName*)
	 * </pre>
	 */
	protected void sequence_PathTypeName(ISerializationContext context, PathTypeName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationalExpression returns RelationalExpression
	 *
	 * Constraint:
	 *     (exp+=AdditiveExpression (op+=RelationalOperator exp+=AdditiveExpression)?)
	 * </pre>
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationalOperator returns RelationalOperator
	 *
	 * Constraint:
	 *     (
	 *         name='=' | 
	 *         name='&gt;' | 
	 *         name='&lt;' | 
	 *         name='&gt;=' | 
	 *         name='&lt;=' | 
	 *         name='&lt;&gt;'
	 *     )
	 * </pre>
	 */
	protected void sequence_RelationalOperator(ISerializationContext context, RelationalOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TimeExpression returns TimeExpression
	 *
	 * Constraint:
	 *     name=NAME_TERMINAL
	 * </pre>
	 */
	protected void sequence_TimeExpression(ISerializationContext context, TimeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.TIME_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.TIME_EXPRESSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeExpressionAccess().getNameNAME_TERMINALTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Name returns TwoIntegerParamFunction
	 *     Function returns TwoIntegerParamFunction
	 *     TwoIntegerParamFunction returns TwoIntegerParamFunction
	 *
	 * Constraint:
	 *     (name='substring' | name='subSequence' | name='subOrderedSet')
	 * </pre>
	 */
	protected void sequence_TwoIntegerParamFunction(ISerializationContext context, TwoIntegerParamFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Name returns TwoStringParamFunction
	 *     Function returns TwoStringParamFunction
	 *     TwoStringParamFunction returns TwoStringParamFunction
	 *
	 * Constraint:
	 *     (name='replaceAll' | name='regexReplaceAll')
	 * </pre>
	 */
	protected void sequence_TwoStringParamFunction(ISerializationContext context, TwoStringParamFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeName returns TypeName
	 *
	 * Constraint:
	 *     name=TYPENAME_TERMINAL
	 * </pre>
	 */
	protected void sequence_TypeName(ISerializationContext context, TypeName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OclPackage.Literals.TYPE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OclPackage.Literals.TYPE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeNameAccess().getNameTYPENAME_TERMINALTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (op+=UnaryOperator* exp=PostfixExpression)
	 * </pre>
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnaryOperator returns UnaryOperator
	 *
	 * Constraint:
	 *     (name='-' | name='not')
	 * </pre>
	 */
	protected void sequence_UnaryOperator(ISerializationContext context, UnaryOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
